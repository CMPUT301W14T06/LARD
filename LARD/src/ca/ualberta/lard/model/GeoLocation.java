package ca.ualberta.lard.model;

import java.util.ArrayList;
import com.google.gson.Gson;
import android.content.Context;
import android.location.Location;
import android.location.LocationManager;

/**
 * A GeoLocation is composed of a latitude and a longitude, and as the name
 * suggests it represents a location in the world. It can be set
 * using specific coordinates or it can be set by getting the position of 
 * the users device in the world.
 */

public class GeoLocation {
	
	private double lon;
	private double lat;
	
	public ArrayList<GeoLocation> locations;
	
	
	/**
	 * Creates a GeoLocation using the position of the device.
	 * @param context
	 */
	public GeoLocation(Context context) {
		LocationManager lm = (LocationManager)context.getSystemService(Context.LOCATION_SERVICE); 
		Location location = lm.getLastKnownLocation(LocationManager.GPS_PROVIDER);
		if (location == null) {
			location = lm.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);
		}
		// Can't find location. They're in compsci
		if (location == null) {
			this.lon = 53.526808 ;
			this.lat = -113.527127;
		} else {
			this.lon = location.getLongitude();
			this.lat = location.getLatitude();
		}
	}
	
	/**
	 * Creates a GeoLocation using a input latitude and longitude.
	 * @param lat
	 * @param lon
	 */
	public GeoLocation (double lat, double lon) {
		this.lon = lon;
		this.lat = lat;
	}
	
	
	public double getLatitude() {
		return this.lat;
	}
	
	public double getLongitude() {
		return this.lon;
	}
	
	/**
	 * Finds the distance from current location to a specified GeoLocation.
	 * 
	 * Credit: base code for the haversine formula here: http://www.movable-type.co.uk/scripts/latlong.html
	 * 
	 * @param loc1
	 * @return the distance as a double
	 */
	public double distanceFrom(GeoLocation loc1) {
		
		int earthRadius = 6371; // earth's radius in KM - constant in source code because we don't expect this to change - ever.
		double dLat = Math.toRadians(this.getLatitude() - loc1.getLatitude());
		double dLon = Math.toRadians(this.getLongitude() - loc1.getLongitude());
		double lat1 = Math.toRadians(loc1.getLatitude());
		double lat2 = Math.toRadians(this.getLatitude());

		double a = Math.sin(dLat/2) * Math.sin(dLat/2) +
		        Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); 
		double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
		return earthRadius * c;
	}
	
	/**
	 * Returns GeoLocation model as a json object.
	 * @return The GeoLocation as a json object.
	 */
	public String toJSON() {
		Gson gson = new Gson();
		String json = gson.toJson(this);
		return json;
	}
	
	/**
	 * Returns a GeoLocation model from a Json object.
	 * @param text
	 * @return GeoLocation model
	 */
	public static GeoLocation fromJSON(String text) {
		Gson gson = new Gson();
		GeoLocation new_model = gson.fromJson(text, GeoLocation.class);
		return new_model;
	}


	/**
	 * Auto-generated by eclipse
	 * (Source -> generate hashCode and equals)
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		long temp;
		temp = Double.doubleToLongBits(lat);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		temp = Double.doubleToLongBits(lon);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		return result;
	}

	/**
	 * Auto-generated by eclipse
	 * (Source -> generate hashCode and equals)
	 * Used for comparing if two GeoLocations are equal.
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		GeoLocation other = (GeoLocation) obj;
		if (Double.doubleToLongBits(lat) != Double.doubleToLongBits(other.lat))
			return false;
		if (Double.doubleToLongBits(lon) != Double.doubleToLongBits(other.lon))
			return false;
		return true;
	}

}
